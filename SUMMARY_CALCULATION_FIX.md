# 科室汇总表计算逻辑修复

## 问题描述

科室业务价值汇总表的数据计算存在问题：

### 原有问题
- 序列价值计算逻辑复杂且不准确
- 只统计末级维度，忽略了中间层级的维度
- 父子关系判断逻辑有缺陷

### 正确逻辑
1. **各序列价值** = 该序列下所有维度的价值总和（不区分层级）
2. **科室总价值** = 医 + 护 + 技三个序列的价值之和
3. **各序列占比** = 序列价值 / 科室总价值 × 100%

## 修复方案

### 1. 序列价值计算 - 参考明细表算法

直接使用业务价值明细表的逐级汇总算法（`calculate_sum_from_children`）：

```python
# 构建节点映射
result_map = {d.node_id: d for d in all_dimensions}

# 递归函数：从子节点汇总价值（参考明细表的 calculate_sum_from_children）
def calculate_sum_from_children(node_id: int) -> Decimal:
    """递归计算节点的价值（从子节点汇总）"""
    result = result_map.get(node_id)
    if not result:
        return Decimal("0")
    
    # 查找该节点的所有子节点
    children = [d for d in all_dimensions if d.parent_id == node_id]
    
    if not children:
        # 叶子节点，直接返回自己的价值
        return result.value or Decimal("0")
    
    # 非叶子节点，汇总子节点的价值
    total_value = Decimal("0")
    for child in children:
        child_value = calculate_sum_from_children(child.node_id)
        total_value += child_value
    
    return total_value

# 找出该序列的直接子维度（一级维度）
first_level_dimensions = [
    d for d in all_dimensions 
    if d.parent_id == seq_node.id
]

# 汇总一级维度的价值（会递归汇总所有子孙节点）
sequence_value = Decimal("0")
for dim in first_level_dimensions:
    dim_value = calculate_sum_from_children(dim.node_id)
    sequence_value += dim_value
```

### 2. 关键改进

1. **参考明细表算法**: 直接使用业务价值明细表已验证的逐级汇总算法
2. **递归汇总**: 从叶子节点开始，逐级向上汇总价值
3. **避免重复计算**: 只统计一级维度，通过递归自动汇总所有子孙节点
4. **算法一致性**: 确保汇总表和明细表使用相同的计算逻辑

### 3. 计算流程（逐级汇总）

```
序列A (医生序列)
├── 维度1 (门诊诊察)
│   ├── 维度1.1 (普通门诊) - 叶子节点价值: 6000
│   └── 维度1.2 (专家门诊) - 叶子节点价值: 4000
│   → 维度1汇总价值 = 6000 + 4000 = 10000
└── 维度2 (住院诊察)
    ├── 维度2.1 (普通病房) - 叶子节点价值: 8000
    └── 维度2.2 (重症病房) - 叶子节点价值: 7000
    → 维度2汇总价值 = 8000 + 7000 = 15000

序列A价值 = 维度1汇总 + 维度2汇总 = 10000 + 15000 = 25000
```

**关键点**:
- 叶子节点：直接使用自己的价值（工作量 × 权重）
- 非叶子节点：价值 = 所有子节点价值之和（递归汇总）
- 序列价值：所有一级维度的汇总价值之和
- **不会重复统计**：每个叶子节点的价值只计算一次

## 验证工具

### 1. 验证脚本

创建了 `verify_summary_calculation.py` 用于验证计算逻辑：

```bash
# 验证最新任务
python backend/verify_summary_calculation.py

# 验证指定周期
python backend/verify_summary_calculation.py --period 2025-10

# 验证指定任务
python backend/verify_summary_calculation.py --task-id report-2025-10-xxx
```

### 2. 批处理文件

创建了 `verify-summary.bat` 方便Windows用户使用：

```bash
verify-summary.bat
```

### 3. 验证内容

验证脚本会检查：

1. **序列价值**: 序列价值 = 该序列下所有维度的价值总和
2. **科室总价值**: 总价值 = 医生价值 + 护理价值 + 医技价值
3. **序列占比**: 占比 = 序列价值 / 总价值 × 100%
4. **占比总和**: 医生占比 + 护理占比 + 医技占比 ≈ 100%

## 使用步骤

### 步骤1: 重新生成数据

```bash
# 清理并重新生成数据
python backend/populate_report_data.py --period 2025-10 --random
```

### 步骤2: 验证计算结果

```bash
# 验证生成的数据
python backend/verify_summary_calculation.py --period 2025-10
```

### 步骤3: 检查输出

验证脚本会输出详细的检查结果：

```
================================================================================
科室汇总表计算验证
================================================================================
任务ID: report-2025-10-20251030123456

找到 10 个科室的汇总数据

--------------------------------------------------------------------------------
科室: 001 - 心内科
--------------------------------------------------------------------------------

1. 序列数据 (3 个):
  ✅ 医生序列:
      序列价值: 150000.00
      维度总和: 150000.00 (5 个维度)
  ✅ 护理序列:
      序列价值: 100000.00
      维度总和: 100000.00 (4 个维度)
  ✅ 医技序列:
      序列价值: 80000.00
      维度总和: 80000.00 (3 个维度)

2. 汇总表数据:
  ✅ 医生价值: 150000.00 (计算值: 150000.00)
  ✅ 护理价值: 100000.00 (计算值: 100000.00)
  ✅ 医技价值: 80000.00 (计算值: 80000.00)
  ✅ 科室总价值: 330000.00 (计算值: 330000.00)

3. 占比验证:
  ✅ 医生占比: 45.45% (计算值: 45.45%)
  ✅ 护理占比: 30.30% (计算值: 30.30%)
  ✅ 医技占比: 24.24% (计算值: 24.24%)
  ✅ 占比总和: 99.99% (应为 100%)

================================================================================
✅ 所有科室的汇总数据计算正确!
================================================================================
```

## 注意事项

### 1. 维度层级关系

如果模型中的维度有多层嵌套关系，需要注意：

- **方案A**: 父维度价值 = 子维度价值之和（推荐）
  - 这种情况下，只统计末级维度即可
  - 需要修改代码，只统计叶子节点

- **方案B**: 父维度和子维度价值独立（当前实现）
  - 父维度有自己的工作量和价值
  - 子维度也有自己的工作量和价值
  - 序列价值 = 所有维度价值之和（不会重复）

### 2. 数据一致性

确保：
- 维度的 `parent_id` 正确指向序列或父维度
- 序列的 `parent_id` 为 NULL
- 模型结构完整且无循环引用

### 3. 性能考虑

- 递归查找可能影响性能
- 对于大量科室和维度，考虑优化查询
- 可以缓存节点关系映射

## 相关文件

- `backend/populate_report_data.py` - 数据填充脚本（已修复）
- `backend/verify_summary_calculation.py` - 验证脚本（新增）
- `verify-summary.bat` - 验证批处理文件（新增）
- `POPULATE_REPORT_DATA_GUIDE.md` - 数据填充指南

## 后续优化

1. **性能优化**: 使用SQL递归查询替代Python递归
2. **缓存机制**: 缓存节点关系映射，避免重复查询
3. **批量处理**: 优化批量插入和更新操作
4. **错误处理**: 增加更详细的错误提示和日志

## 测试建议

1. 测试单层维度结构
2. 测试多层嵌套维度结构
3. 测试空数据情况
4. 测试大量科室和维度的性能
5. 测试边界情况（价值为0、负数等）
