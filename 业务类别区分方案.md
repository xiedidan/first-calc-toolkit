# 业务类别区分方案

## 背景

收费明细表新增了 `business_type` 字段（门诊/住院），需要在计算流程中根据维度的业务类别分别统计对应的收费明细。

## 方案设计

### 核心思路

通过维度的层级结构（路径）自动判断业务类别，而不是在映射表中添加字段。

### 业务类别判断规则

根据维度在模型树中的路径，自动判断其业务类别：

| 维度路径 | 业务类别 | 说明 |
|---------|---------|------|
| 医生序列/门诊/... | 门诊 | 医生序列下的门诊一级维度及其子维度 |
| 医生序列/住院/... | 住院 | 医生序列下的住院一级维度及其子维度 |
| 医生序列/手术/门诊/... | 门诊 | 医生序列-手术下的门诊二级维度及其子维度 |
| 医生序列/手术/住院/... | 住院 | 医生序列-手术下的住院二级维度及其子维度 |
| 护理序列/病区/... | 住院 | 护理序列下的病区一级维度及其子维度 |
| 护理序列/非病区/... | 门诊 | 护理序列下的非病区一级维度及其子维度 |
| 医技序列/... | NULL（不区分） | 医技序列下的所有维度不区分门诊住院 |

### 实现方式

修改 `step1_dimension_catalog.sql`，增加以下逻辑：

1. **构建维度层级结构**：使用递归CTE从序列节点开始，向下递归获取所有维度节点，构建完整路径
2. **判断业务类别**：根据路径使用CASE语句判断业务类别
3. **关联收费明细**：在JOIN时增加业务类别匹配条件

```sql
-- 关键JOIN条件
LEFT JOIN charge_data cd ON dm.item_code = cd.item_code
    AND (
        dm.business_type IS NULL  -- 维度不区分业务类别(如医技)
        OR dm.business_type = cd.business_type  -- 业务类别匹配
    )
```

## 优势

1. **无需修改数据库结构**：不需要在映射表中添加字段
2. **自动判断**：根据模型结构自动判断，无需人工配置
3. **灵活性高**：如果模型结构调整，判断逻辑自动适应
4. **易于维护**：业务规则集中在SQL中，便于理解和修改

## 测试验证

使用 `test-business-type-logic.sql` 脚本验证：

```bash
psql -h localhost -U admin -d hospital_value -P pager=off -f test-business-type-logic.sql
```

预期结果：
- 医生序列-门诊下的维度：business_type = '门诊'
- 医生序列-住院下的维度：business_type = '住院'
- 医生序列-手术-门诊下的维度：business_type = '门诊'
- 医生序列-手术-住院下的维度：business_type = '住院'
- 护理序列-病区下的维度：business_type = '住院'
- 护理序列-非病区下的维度：business_type = '门诊'
- 医技序列下的维度：business_type = NULL

## 注意事项

1. **路径匹配规则**：使用 `LIKE` 进行模糊匹配，需要确保序列和维度的命名规范
2. **收费明细字段**：
   - 字段名已统一为 `business_type`（已修正数据集文档中的拼写错误）
   - 字段值应为 '门诊' 或 '住院'
3. **占位符替换**：SQL中的 `{version_id}` 占位符需要在执行时正确替换
4. **模型结构要求**：
   - 序列节点命名：医生序列、护理序列、医技序列
   - 一级维度命名：门诊、住院、手术、病区、非病区等

## 后续工作

1. ✅ 已修正数据集文档中的字段名拼写
2. ✅ 已实现业务类别区分逻辑
3. 测试完整的计算流程，验证门诊和住院数据是否正确分离
4. 如有需要，调整路径匹配规则以适应实际的模型结构
5. 考虑是否需要处理其他业务类别（如急诊、体检等）
