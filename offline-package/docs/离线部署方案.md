# 医院科室业务价值评估工具 - 离线部署方案

> **文档版本**: 1.0  
> **创建日期**: 2025-10-29  
> **适用场景**: 无互联网连接的Linux服务器环境

---

## 1. 方案概述

### 1.1. 部署场景

**目标环境特点**：
- ❌ 无互联网连接（内网隔离环境）
- ❌ 仅有Python 2.7（无法运行Python 3.12应用）
- ❌ 无法使用pip、npm等在线包管理器
- ✅ 已安装Docker和Docker Compose
- ✅ 已有PostgreSQL数据库实例（可复用）

**迁移需求**：
- 完整的应用代码和运行环境
- 所有依赖包（Python、Node.js、系统库）
- 现有数据库数据（模型、配置、历史结果）
- 快速部署，最小化手动配置

### 1.2. 推荐方案：基于Docker镜像的离线部署

**核心思路**：
1. 在有网络的环境中构建并导出所有Docker镜像
2. 将镜像文件和配置打包传输到目标服务器
3. 在目标服务器导入镜像并启动容器
4. 连接现有PostgreSQL数据库或使用容器内数据库

**方案优势**：
- ✅ 完全不依赖目标服务器的Python环境
- ✅ 所有依赖都封装在Docker镜像中
- ✅ 环境一致性好，避免依赖冲突
- ✅ 部署简单，只需几条Docker命令
- ✅ 支持连接外部PostgreSQL或使用容器内数据库
- ✅ 支持数据库数据的完整迁移

---

## 2. 部署架构

### 2.1. 容器架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    目标Linux服务器（离线）                      │
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │   Frontend   │  │   Backend    │  │    Celery    │      │
│  │   (Nginx)    │  │  (FastAPI)   │  │    Worker    │      │
│  │   容器        │  │   容器        │  │    容器       │      │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘      │
│         │                  │                  │              │
│         │                  └────────┬─────────┘              │
│         │                           │                        │
│  ┌──────▼───────────────────────────▼─────────────────┐    │
│  │              Redis 容器（消息队列）                  │    │
│  └──────────────────────────────────────────────────────┘    │
│                           │                                   │
│                           │                                   │
│  ┌────────────────────────▼──────────────────────────────┐  │
│  │         PostgreSQL（两种模式）                         │  │
│  │  模式1: 外部数据库（已有）                             │  │
│  │  模式2: 容器内数据库（新建）                           │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 2.2. 服务组件说明

| 组件 | 说明 | 镜像大小（估算） |
|------|------|------------------|
| Frontend | Nginx + Vue.js构建产物 | ~50MB |
| Backend | Python 3.12 + FastAPI + 依赖 | ~800MB |
| Celery Worker | 与Backend相同镜像 | ~800MB（共享） |
| Redis | 官方Redis 7镜像 | ~30MB |
| PostgreSQL | 官方PostgreSQL 16镜像（可选） | ~150MB |

**总镜像大小**：约1-1.5GB（压缩后约500-800MB）

---

## 3. 详细部署方案

### 3.1. 方案A：使用外部PostgreSQL数据库（推荐）

**适用场景**：目标服务器已有PostgreSQL实例

**优势**：
- 复用现有数据库，无需额外资源
- 数据库管理更灵活
- 性能更好（无容器网络开销）

**部署步骤**：

1. **在源环境准备部署包**
2. **传输到目标服务器**
3. **导入Docker镜像**
4. **配置数据库连接**
5. **导入数据库数据**
6. **启动服务**

### 3.2. 方案B：使用容器内PostgreSQL数据库

**适用场景**：目标服务器没有PostgreSQL或需要独立数据库

**优势**：
- 完全自包含，不依赖外部服务
- 部署更简单
- 适合测试和演示环境

**部署步骤**：
1. **在源环境准备部署包**（包含PostgreSQL镜像）
2. **传输到目标服务器**
3. **导入Docker镜像**
4. **启动所有服务**（包括PostgreSQL容器）
5. **导入数据库数据**

---

## 4. 部署包制作（在有网络的环境）

### 4.1. 准备工作

**环境要求**：
- Docker 20.10+
- Docker Compose 2.0+
- 足够的磁盘空间（至少10GB）

### 4.2. 构建Docker镜像

创建构建脚本 `build-offline-package.sh`：

```bash
#!/bin/bash
set -e

echo "=== 开始构建离线部署包 ==="

# 1. 构建后端镜像
echo ">>> 构建后端镜像..."
cd backend
docker build -t hospital-backend:latest .
cd ..

# 2. 构建前端镜像
echo ">>> 构建前端镜像..."
cd frontend
docker build -t hospital-frontend:latest .
cd ..

# 3. 拉取Redis镜像
echo ">>> 拉取Redis镜像..."
docker pull redis:7-alpine

# 4. 拉取PostgreSQL镜像（可选）
echo ">>> 拉取PostgreSQL镜像..."
docker pull postgres:16

echo "=== 镜像构建完成 ==="
docker images | grep -E "hospital|redis|postgres"
```

### 4.3. 导出Docker镜像

```bash
#!/bin/bash
set -e

echo "=== 开始导出Docker镜像 ==="

# 创建导出目录
mkdir -p offline-package/images

# 导出后端镜像
echo ">>> 导出后端镜像..."
docker save hospital-backend:latest | gzip > offline-package/images/backend.tar.gz

# 导出前端镜像
echo ">>> 导出前端镜像..."
docker save hospital-frontend:latest | gzip > offline-package/images/frontend.tar.gz

# 导出Redis镜像
echo ">>> 导出Redis镜像..."
docker save redis:7-alpine | gzip > offline-package/images/redis.tar.gz

# 导出PostgreSQL镜像（可选）
echo ">>> 导出PostgreSQL镜像..."
docker save postgres:16 | gzip > offline-package/images/postgres.tar.gz

echo "=== 镜像导出完成 ==="
ls -lh offline-package/images/
```

### 4.4. 导出数据库数据

```bash
#!/bin/bash
set -e

echo "=== 开始导出数据库数据 ==="

# 配置数据库连接信息
DB_HOST="localhost"
DB_PORT="5432"
DB_NAME="hospital_value"
DB_USER="admin"
DB_PASSWORD="admin123"

# 导出数据库结构和数据
echo ">>> 导出数据库..."
PGPASSWORD=$DB_PASSWORD pg_dump \
  -h $DB_HOST \
  -p $DB_PORT \
  -U $DB_USER \
  -d $DB_NAME \
  --clean \
  --if-exists \
  --no-owner \
  --no-privileges \
  -f offline-package/database/hospital_value.sql

# 压缩数据库文件
echo ">>> 压缩数据库文件..."
gzip offline-package/database/hospital_value.sql

echo "=== 数据库导出完成 ==="
ls -lh offline-package/database/
```

### 4.5. 打包配置文件和脚本

```bash
#!/bin/bash
set -e

echo "=== 开始打包配置文件 ==="

# 创建目录结构
mkdir -p offline-package/{config,scripts,docs}

# 复制Docker Compose配置
cp docker-compose.offline.yml offline-package/config/

# 复制环境变量模板
cp backend/.env.offline.template offline-package/config/

# 复制部署脚本
cp scripts/deploy-offline.sh offline-package/scripts/
cp scripts/load-images.sh offline-package/scripts/
cp scripts/init-database.sh offline-package/scripts/

# 复制文档
cp 离线部署方案.md offline-package/docs/
cp OFFLINE_DEPLOYMENT_GUIDE.md offline-package/docs/

# 创建README
cat > offline-package/README.md << 'EOF'
# 医院科室业务价值评估工具 - 离线部署包

## 部署包内容

- `images/` - Docker镜像文件
- `database/` - 数据库数据文件
- `config/` - 配置文件
- `scripts/` - 部署脚本
- `docs/` - 部署文档

## 快速开始

1. 解压部署包
2. 阅读 `docs/OFFLINE_DEPLOYMENT_GUIDE.md`
3. 执行 `scripts/deploy-offline.sh`

详细说明请参考文档。
EOF

echo "=== 配置文件打包完成 ==="
```

### 4.6. 生成最终部署包

```bash
#!/bin/bash
set -e

echo "=== 开始生成最终部署包 ==="

# 获取版本号
VERSION=$(cat backend/app/__init__.py | grep __version__ | cut -d'"' -f2)

# 打包
PACKAGE_NAME="hospital-value-toolkit-offline-v${VERSION}.tar.gz"
tar -czf $PACKAGE_NAME offline-package/

echo "=== 部署包生成完成 ==="
echo "部署包: $PACKAGE_NAME"
ls -lh $PACKAGE_NAME
```

---

## 5. 目标服务器部署（离线环境）

### 5.1. 前置条件检查

创建检查脚本 `check-prerequisites.sh`：

```bash
#!/bin/bash

echo "=== 检查部署前置条件 ==="

# 检查Docker
if command -v docker &> /dev/null; then
    echo "✓ Docker已安装: $(docker --version)"
else
    echo "✗ Docker未安装，请先安装Docker"
    exit 1
fi

# 检查Docker Compose
if command -v docker-compose &> /dev/null; then
    echo "✓ Docker Compose已安装: $(docker-compose --version)"
else
    echo "✗ Docker Compose未安装，请先安装"
    exit 1
fi

# 检查磁盘空间
AVAILABLE_SPACE=$(df -BG . | tail -1 | awk '{print $4}' | sed 's/G//')
if [ $AVAILABLE_SPACE -gt 10 ]; then
    echo "✓ 磁盘空间充足: ${AVAILABLE_SPACE}GB"
else
    echo "✗ 磁盘空间不足，至少需要10GB"
    exit 1
fi

# 检查端口占用
PORTS=(80 8000 6379 5432)
for PORT in "${PORTS[@]}"; do
    if lsof -Pi :$PORT -sTCP:LISTEN -t >/dev/null 2>&1; then
        echo "⚠ 端口 $PORT 已被占用"
    else
        echo "✓ 端口 $PORT 可用"
    fi
done

echo "=== 前置条件检查完成 ==="
```

### 5.2. 导入Docker镜像

创建导入脚本 `load-images.sh`：

```bash
#!/bin/bash
set -e

echo "=== 开始导入Docker镜像 ==="

IMAGES_DIR="./images"

# 导入后端镜像
echo ">>> 导入后端镜像..."
docker load < $IMAGES_DIR/backend.tar.gz

# 导入前端镜像
echo ">>> 导入前端镜像..."
docker load < $IMAGES_DIR/frontend.tar.gz

# 导入Redis镜像
echo ">>> 导入Redis镜像..."
docker load < $IMAGES_DIR/redis.tar.gz

# 导入PostgreSQL镜像（如果存在）
if [ -f "$IMAGES_DIR/postgres.tar.gz" ]; then
    echo ">>> 导入PostgreSQL镜像..."
    docker load < $IMAGES_DIR/postgres.tar.gz
fi

echo "=== 镜像导入完成 ==="
docker images | grep -E "hospital|redis|postgres"
```

### 5.3. 配置环境变量

创建配置模板 `.env.offline.template`：

```bash
# ============================================
# 医院科室业务价值评估工具 - 离线部署配置
# ============================================

# 应用配置
APP_NAME=医院科室业务价值评估工具
APP_VERSION=1.0.0
DEBUG=False

# 数据库配置（请根据实际情况修改）
# 模式1: 使用外部PostgreSQL（推荐）
DATABASE_URL=postgresql://admin:admin123@host.docker.internal:5432/hospital_value

# 模式2: 使用容器内PostgreSQL
# DATABASE_URL=postgresql://admin:admin123@postgres:5432/hospital_value

# Redis配置
REDIS_URL=redis://redis:6379/0

# JWT配置（请修改为随机密钥）
SECRET_KEY=your-secret-key-change-this-in-production
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=1440

# 数据源密码加密密钥（请修改为随机密钥）
ENCRYPTION_KEY=your-encryption-key-change-this-in-production

# Celery配置
CELERY_BROKER_URL=redis://redis:6379/0
CELERY_RESULT_BACKEND=redis://redis:6379/0

# 端口配置
FRONTEND_PORT=80
BACKEND_PORT=8000
```

配置步骤：

```bash
# 1. 复制模板
cp config/.env.offline.template .env

# 2. 编辑配置文件
vi .env

# 3. 生成随机密钥（可选）
python3 -c "import secrets; print(secrets.token_urlsafe(32))"
```

### 5.4. Docker Compose配置

创建 `docker-compose.offline.yml`：


```yaml
version: '3.8'

services:
  # Redis服务
  redis:
    image: redis:7-alpine
    container_name: hospital_redis_offline
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - hospital_network
    restart: always
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # PostgreSQL服务（可选，仅在使用容器内数据库时启用）
  postgres:
    image: postgres:16
    container_name: hospital_postgres_offline
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-hospital_value}
      POSTGRES_USER: ${POSTGRES_USER:-admin}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-admin123}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - hospital_network
    restart: always
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-admin}"]
      interval: 10s
      timeout: 5s
      retries: 5
    # 如果使用外部数据库，注释掉整个postgres服务

  # 后端服务
  backend:
    image: hospital-backend:latest
    container_name: hospital_backend_offline
    env_file:
      - .env
    ports:
      - "${BACKEND_PORT:-8000}:8000"
    volumes:
      - ./logs:/app/logs
    networks:
      - hospital_network
    depends_on:
      redis:
        condition: service_healthy
      # 如果使用容器内数据库，取消下面的注释
      # postgres:
      #   condition: service_healthy
    restart: always
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000

  # Celery Worker服务
  celery-worker:
    image: hospital-backend:latest
    container_name: hospital_celery_offline
    env_file:
      - .env
    volumes:
      - ./logs:/app/logs
    networks:
      - hospital_network
    depends_on:
      - redis
      - backend
    restart: always
    command: celery -A app.celery_app worker --loglevel=info

  # 前端服务
  frontend:
    image: hospital-frontend:latest
    container_name: hospital_frontend_offline
    ports:
      - "${FRONTEND_PORT:-80}:80"
    networks:
      - hospital_network
    depends_on:
      - backend
    restart: always

volumes:
  redis_data:
    name: hospital_redis_data_offline
  postgres_data:
    name: hospital_postgres_data_offline

networks:
  hospital_network:
    name: hospital_network_offline
    driver: bridge
```

### 5.5. 初始化数据库

创建数据库初始化脚本 `init-database.sh`：

```bash
#!/bin/bash
set -e

echo "=== 开始初始化数据库 ==="

# 读取配置
source .env

# 提取数据库连接信息
DB_HOST=$(echo $DATABASE_URL | sed -n 's/.*@\(.*\):.*/\1/p')
DB_PORT=$(echo $DATABASE_URL | sed -n 's/.*:\([0-9]*\)\/.*/\1/p')
DB_NAME=$(echo $DATABASE_URL | sed -n 's/.*\/\(.*\)/\1/p')
DB_USER=$(echo $DATABASE_URL | sed -n 's/.*\/\/\(.*\):.*/\1/p')
DB_PASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/.*:\(.*\)@.*/\1/p')

echo "数据库主机: $DB_HOST"
echo "数据库端口: $DB_PORT"
echo "数据库名称: $DB_NAME"

# 等待数据库就绪
echo ">>> 等待数据库就绪..."
for i in {1..30}; do
    if PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d postgres -c '\q' 2>/dev/null; then
        echo "✓ 数据库连接成功"
        break
    fi
    echo "等待数据库启动... ($i/30)"
    sleep 2
done

# 导入数据库数据
if [ -f "database/hospital_value.sql.gz" ]; then
    echo ">>> 导入数据库数据..."
    gunzip -c database/hospital_value.sql.gz | \
        PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME
    echo "✓ 数据库数据导入完成"
else
    echo "⚠ 未找到数据库数据文件，跳过导入"
    echo ">>> 执行数据库迁移..."
    docker exec hospital_backend_offline alembic upgrade head
fi

echo "=== 数据库初始化完成 ==="
```

### 5.6. 一键部署脚本

创建主部署脚本 `deploy-offline.sh`：

```bash
#!/bin/bash
set -e

echo "=========================================="
echo "  医院科室业务价值评估工具 - 离线部署"
echo "=========================================="

# 1. 检查前置条件
echo ""
echo "步骤 1/6: 检查前置条件"
bash scripts/check-prerequisites.sh

# 2. 导入Docker镜像
echo ""
echo "步骤 2/6: 导入Docker镜像"
bash scripts/load-images.sh

# 3. 配置环境
echo ""
echo "步骤 3/6: 配置环境"
if [ ! -f ".env" ]; then
    echo ">>> 创建配置文件..."
    cp config/.env.offline.template .env
    echo "⚠ 请编辑 .env 文件，配置数据库连接等信息"
    echo "配置完成后，重新运行此脚本"
    exit 0
else
    echo "✓ 配置文件已存在"
fi

# 4. 启动服务
echo ""
echo "步骤 4/6: 启动服务"
docker-compose -f config/docker-compose.offline.yml up -d

# 5. 等待服务就绪
echo ""
echo "步骤 5/6: 等待服务就绪"
sleep 10

# 6. 初始化数据库
echo ""
echo "步骤 6/6: 初始化数据库"
bash scripts/init-database.sh

# 验证部署
echo ""
echo "=========================================="
echo "  部署完成！"
echo "=========================================="
echo ""
echo "服务访问地址："
echo "  前端: http://localhost:${FRONTEND_PORT:-80}"
echo "  后端API: http://localhost:${BACKEND_PORT:-8000}/docs"
echo ""
echo "查看服务状态："
echo "  docker-compose -f config/docker-compose.offline.yml ps"
echo ""
echo "查看日志："
echo "  docker-compose -f config/docker-compose.offline.yml logs -f"
echo ""
```

---

## 6. 部署验证

### 6.1. 检查容器状态

```bash
# 查看所有容器
docker-compose -f config/docker-compose.offline.yml ps

# 预期输出：所有容器状态为 Up
```

### 6.2. 检查服务健康

```bash
# 检查后端健康
curl http://localhost:8000/health

# 检查前端
curl http://localhost:80

# 检查Redis
docker exec hospital_redis_offline redis-cli ping
```

### 6.3. 测试登录功能

```bash
# 访问前端页面
http://localhost:80

# 使用默认账号登录
# 用户名: admin
# 密码: admin123
```

### 6.4. 查看日志

```bash
# 查看所有服务日志
docker-compose -f config/docker-compose.offline.yml logs -f

# 查看特定服务日志
docker logs hospital_backend_offline
docker logs hospital_frontend_offline
docker logs hospital_celery_offline
```

---

## 7. 常见问题排查

### 7.1. 镜像导入失败

**问题**：`docker load` 报错

**可能原因**：
- 磁盘空间不足
- 镜像文件损坏
- Docker版本不兼容

**解决方案**：
```bash
# 检查磁盘空间
df -h

# 验证镜像文件完整性
gunzip -t images/backend.tar.gz

# 清理Docker缓存
docker system prune -a
```

### 7.2. 容器启动失败

**问题**：容器无法启动或频繁重启

**可能原因**：
- 端口被占用
- 配置文件错误
- 依赖服务未就绪

**解决方案**：
```bash
# 检查端口占用
netstat -tlnp | grep -E "80|8000|6379|5432"

# 查看容器日志
docker logs hospital_backend_offline

# 检查配置文件
cat .env
```

### 7.3. 数据库连接失败

**问题**：后端无法连接数据库

**可能原因**：
- 数据库连接信息错误
- 网络不通
- 数据库未启动

**解决方案**：
```bash
# 测试数据库连接
psql -h localhost -p 5432 -U admin -d hospital_value

# 检查Docker网络
docker network inspect hospital_network_offline

# 如果使用外部数据库，检查host.docker.internal
docker exec hospital_backend_offline ping host.docker.internal
```

### 7.4. 前端无法访问后端

**问题**：前端页面加载但API调用失败

**可能原因**：
- Nginx反向代理配置错误
- 后端服务未启动
- 网络隔离

**解决方案**：
```bash
# 检查Nginx配置
docker exec hospital_frontend_offline cat /etc/nginx/conf.d/default.conf

# 测试后端API
curl http://localhost:8000/docs

# 检查容器间网络
docker exec hospital_frontend_offline ping backend
```

---

## 8. 维护操作

### 8.1. 停止服务

```bash
docker-compose -f config/docker-compose.offline.yml stop
```

### 8.2. 启动服务

```bash
docker-compose -f config/docker-compose.offline.yml start
```

### 8.3. 重启服务

```bash
docker-compose -f config/docker-compose.offline.yml restart
```

### 8.4. 备份数据库

```bash
#!/bin/bash
# backup-database.sh

BACKUP_DIR="./backups"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/hospital_value_$TIMESTAMP.sql.gz"

mkdir -p $BACKUP_DIR

# 读取配置
source .env
DB_HOST=$(echo $DATABASE_URL | sed -n 's/.*@\(.*\):.*/\1/p')
DB_PORT=$(echo $DATABASE_URL | sed -n 's/.*:\([0-9]*\)\/.*/\1/p')
DB_NAME=$(echo $DATABASE_URL | sed -n 's/.*\/\(.*\)/\1/p')
DB_USER=$(echo $DATABASE_URL | sed -n 's/.*\/\/\(.*\):.*/\1/p')
DB_PASSWORD=$(echo $DATABASE_URL | sed -n 's/.*:\/\/.*:\(.*\)@.*/\1/p')

# 备份
PGPASSWORD=$DB_PASSWORD pg_dump \
  -h $DB_HOST \
  -p $DB_PORT \
  -U $DB_USER \
  -d $DB_NAME | gzip > $BACKUP_FILE

echo "数据库备份完成: $BACKUP_FILE"
```

### 8.5. 查看资源使用

```bash
# 查看容器资源使用
docker stats

# 查看磁盘使用
docker system df
```

---

## 9. 性能优化建议

### 9.1. 硬件配置建议

**最低配置**：
- CPU: 4核心
- 内存: 8GB
- 磁盘: 50GB SSD

**推荐配置**：
- CPU: 8核心或更多
- 内存: 16GB或更多
- 磁盘: 100GB SSD或更多

### 9.2. Docker配置优化

编辑 `/etc/docker/daemon.json`：

```json
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  },
  "storage-driver": "overlay2"
}
```

### 9.3. PostgreSQL配置优化

如果使用容器内PostgreSQL，可以调整配置：

```yaml
postgres:
  environment:
    POSTGRES_INITDB_ARGS: "-E UTF8 --locale=C"
  command: >
    postgres
    -c shared_buffers=256MB
    -c effective_cache_size=1GB
    -c maintenance_work_mem=64MB
    -c checkpoint_completion_target=0.9
    -c wal_buffers=16MB
    -c default_statistics_target=100
    -c random_page_cost=1.1
    -c effective_io_concurrency=200
    -c work_mem=4MB
    -c min_wal_size=1GB
    -c max_wal_size=4GB
```

---

## 10. 总结

### 10.1. 方案对比

| 特性 | 方案A（外部PG） | 方案B（容器PG） |
|------|----------------|----------------|
| 部署复杂度 | 中等 | 简单 |
| 资源占用 | 较低 | 较高 |
| 性能 | 更好 | 良好 |
| 数据管理 | 灵活 | 受限 |
| 适用场景 | 生产环境 | 测试/演示 |

### 10.2. 推荐选择

- **生产环境**：推荐方案A（使用外部PostgreSQL）
- **测试环境**：推荐方案B（使用容器内PostgreSQL）
- **演示环境**：推荐方案B（使用容器内PostgreSQL）

### 10.3. 下一步

部署完成后，您可以：
1. 创建初始管理员用户
2. 配置系统设置（当期年月等）
3. 导入评估模型
4. 开始使用系统

---

## 附录

### A. 完整文件清单

```
offline-package/
├── README.md
├── images/
│   ├── backend.tar.gz
│   ├── frontend.tar.gz
│   ├── redis.tar.gz
│   └── postgres.tar.gz
├── database/
│   └── hospital_value.sql.gz
├── config/
│   ├── docker-compose.offline.yml
│   └── .env.offline.template
├── scripts/
│   ├── check-prerequisites.sh
│   ├── load-images.sh
│   ├── init-database.sh
│   ├── deploy-offline.sh
│   └── backup-database.sh
└── docs/
    ├── 离线部署方案.md
    └── OFFLINE_DEPLOYMENT_GUIDE.md
```

### B. 端口使用说明

| 端口 | 服务 | 说明 |
|------|------|------|
| 80 | Frontend | 前端Web界面 |
| 8000 | Backend | 后端API服务 |
| 6379 | Redis | 消息队列 |
| 5432 | PostgreSQL | 数据库（可选） |

### C. 环境变量完整列表

详见 `.env.offline.template` 文件。

---

**文档结束**
